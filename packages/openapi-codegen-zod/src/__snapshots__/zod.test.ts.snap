// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`generateZod > circular schema > circular 1`] = `
"import { z } from 'zod'
import * as zc from './zod-common.js'

export namespace Schemas {
    export const Node: z.ZodTypeAny = z.lazy(() => z.object({ id: z.string().optional(), parent: Node.optional(), children: z.lazy(() => z.array(Node)).optional() }));

    export namespace Types {
        export type Node = z.infer<typeof Schemas.Node>;
    }

}
"
`;

exports[`generateZod > fullmetal > fullmetal/openapi.yml 1`] = `
"import { z } from 'zod'
import * as zc from './zod-common.js'

export namespace Schemas {
    export const RegisterResponse = z.object({ token: z.string(), userId: z.string() });
    export const LoginResponse = z.object({ token: z.string() });
    export const LoginRequest = z.object({ username: z.string(), password: z.string() });
    export const InventoryStockItem = z.object({ quantity: z.number(), priceEuro: z.number(), purchaseDate: z.string(), stockId: z.string(), productId: z.string() });
    export const InventoryStockHistory = z.object({ eventDate: z.string(), eventPrice: z.number(), deltaRevenue: z.number(), event: z.enum(['GIFTED', 'SOLD', 'PURCHASED']).or(z.string().transform((s) => \`unknown:\${s}\` as const)), quantity: z.number(), priceEuro: z.number(), purchaseDate: z.string(), stockId: z.string(), productId: z.string() });
    export const InventoryStock = z.object({ history: z.array(InventoryStockHistory), inventory: z.array(InventoryStockItem), quantity: z.number() });
    export const InventoryItemStats = z.object({ totalPurchase: z.number(), totalSells: z.number() });
    export const WeightUnit = z.enum(['kg', 'g', 'oz_tr']).or(z.string().transform((s) => \`unknown:\${s}\` as const));
    export const Weight = z.object({ unit: WeightUnit, value: z.number() });
    export const ItemType = z.enum(['B', 'El', 'kA', 'Ka', 'KA', 'KR', 'Pa', 'LIII', 'ML', 'R', 'Phil', 'BR']).or(z.string().transform((s) => \`unknown:\${s}\` as const));
    export const Product = z.object({ externalId: z.string().optional(), itemType: ItemType, weight: Weight, productId: z.string() });
    export const InventoryItem = z.object({ inventoryId: z.string(), product: Product.optional(), quantity: z.number(), invest: z.number().optional(), stats: InventoryItemStats.optional(), revenue: z.number().optional(), stock: InventoryStock.optional() });
    export const InventorySummaryResponse = z.object({ message: z.enum(['ok']).or(z.string().transform((s) => \`unknown:\${s}\` as const)), items: z.array(InventoryItem) });
    export const ChangeItemDetails = z.object({ quantity: z.number().optional(), priceEuro: z.number().optional(), purchaseDate: z.string().optional() });
    export const ChangeItemRequest = z.object({ createdAt: z.string(), event: z.enum(['PURCHASED', 'GIFTED', 'SOLD']).or(z.string().transform((s) => \`unknown:\${s}\` as const)), details: ChangeItemDetails });
    export const SuccessResponse = z.object({ message: z.enum(['ok']).or(z.string().transform((s) => \`unknown:\${s}\` as const)) });
    export const UpdateItemRequestDetails = z.object({ quantity: z.number().optional(), priceEuro: z.number().optional(), purchaseDate: z.string().optional(), stockId: z.string(), productId: z.string() });
    export const UpdateItemRequest = z.object({ event: z.enum(['UPDATED']).or(z.string().transform((s) => \`unknown:\${s}\` as const)), createdAt: z.string(), details: UpdateItemRequestDetails });
    export const PurchasedEventDetailBase = z.object({ kind: z.string().optional() });
    export const PurchasedEventDetailItemProduct = PurchasedEventDetailBase.merge(z.object({ kind: z.string().optional().default('PRODUCT_REF'), productId: z.string() }));
    export const PurchasedEventDetailItemSpecified = PurchasedEventDetailBase.merge(z.object({ kind: z.string().optional().default('SPECIFIED'), itemType: ItemType, weight: Weight }));
    export const PurchasedEventDetailItem = z.union([PurchasedEventDetailItemSpecified, PurchasedEventDetailItemProduct]);
    export const PurchasedEventDetail = z.object({ item: PurchasedEventDetailItem, quantity: z.number(), priceEuro: z.number(), purchaseDate: z.string().optional() });
    export const CreateItemDetails = z.object({ details: PurchasedEventDetail });
    export const CreateItem = z.object({ details: CreateItemDetails });
    export const InventoryItemList = z.object({ items: z.array(InventoryItem) });
    export const Error = z.object({ error: z.string().optional() });
    export const ChangeConstantBase = z.object({ event: z.string() });
    export const GoldPriceUpdateDetails = z.object({ unit: WeightUnit, price: z.number() });
    export const ChangeConstantUser = ChangeConstantBase.merge(z.object({ inventoryId: z.string(), details: GoldPriceUpdateDetails, event: z.literal('UPDATE_DOUGH_PRICE').default('UPDATE_DOUGH_PRICE') }));
    export const ChangeConstantGlobal = ChangeConstantBase.merge(z.object({ details: GoldPriceUpdateDetails, event: z.literal('GLOBAL_UPDATE_DOUGH_PRICE') }));
    export const ChangeConstant = zc.ZodUnionMatch.matcher("event", { 'UPDATE_DOUGH_PRICE': ChangeConstantUser, 'GLOBAL_UPDATE_DOUGH_PRICE': ChangeConstantGlobal, onDefault: z.object({ event: z.string().transform((s) => \`unknown:\${s}\` as const) }).passthrough() });
    export const GoldPriceRates = z.object({ g: z.number(), kg: z.number(), oz_tr: z.number() });
    export const ConstantBase = z.object({ version: z.number(), updatedAt: z.string(), ratesByWeight: GoldPriceRates });
    export const Constant = z.object({ history: ConstantBase.optional(), version: z.number(), updatedAt: z.string(), ratesByWeight: GoldPriceRates });
    export const Constants = z.object({ doughPrices: Constant });

    export namespace Types {
        export type RegisterResponse = z.infer<typeof Schemas.RegisterResponse>;
        export type LoginResponse = z.infer<typeof Schemas.LoginResponse>;
        export type LoginRequest = z.infer<typeof Schemas.LoginRequest>;
        export type InventoryStockItem = z.infer<typeof Schemas.InventoryStockItem>;
        export type InventoryStockHistory = z.infer<typeof Schemas.InventoryStockHistory>;
        export type InventoryStock = z.infer<typeof Schemas.InventoryStock>;
        export type InventoryItemStats = z.infer<typeof Schemas.InventoryItemStats>;
        export type WeightUnit = z.infer<typeof Schemas.WeightUnit>;
        export type Weight = z.infer<typeof Schemas.Weight>;
        export type ItemType = z.infer<typeof Schemas.ItemType>;
        export type Product = z.infer<typeof Schemas.Product>;
        export type InventoryItem = z.infer<typeof Schemas.InventoryItem>;
        export type InventorySummaryResponse = z.infer<typeof Schemas.InventorySummaryResponse>;
        export type ChangeItemDetails = z.infer<typeof Schemas.ChangeItemDetails>;
        export type ChangeItemRequest = z.infer<typeof Schemas.ChangeItemRequest>;
        export type SuccessResponse = z.infer<typeof Schemas.SuccessResponse>;
        export type UpdateItemRequestDetails = z.infer<typeof Schemas.UpdateItemRequestDetails>;
        export type UpdateItemRequest = z.infer<typeof Schemas.UpdateItemRequest>;
        export type PurchasedEventDetailBase = z.infer<typeof Schemas.PurchasedEventDetailBase>;
        export type PurchasedEventDetailItemProduct = z.infer<typeof Schemas.PurchasedEventDetailItemProduct>;
        export type PurchasedEventDetailItemSpecified = z.infer<typeof Schemas.PurchasedEventDetailItemSpecified>;
        export type PurchasedEventDetailItem = z.infer<typeof Schemas.PurchasedEventDetailItem>;
        export type PurchasedEventDetail = z.infer<typeof Schemas.PurchasedEventDetail>;
        export type CreateItemDetails = z.infer<typeof Schemas.CreateItemDetails>;
        export type CreateItem = z.infer<typeof Schemas.CreateItem>;
        export type InventoryItemList = z.infer<typeof Schemas.InventoryItemList>;
        export type Error = z.infer<typeof Schemas.Error>;
        export type ChangeConstantBase = z.infer<typeof Schemas.ChangeConstantBase>;
        export type GoldPriceUpdateDetails = z.infer<typeof Schemas.GoldPriceUpdateDetails>;
        export type ChangeConstantUser = z.infer<typeof Schemas.ChangeConstantUser>;
        export type ChangeConstantGlobal = z.infer<typeof Schemas.ChangeConstantGlobal>;
        export type ChangeConstant = z.infer<typeof Schemas.ChangeConstant>;
        export type GoldPriceRates = z.infer<typeof Schemas.GoldPriceRates>;
        export type ConstantBase = z.infer<typeof Schemas.ConstantBase>;
        export type Constant = z.infer<typeof Schemas.Constant>;
        export type Constants = z.infer<typeof Schemas.Constants>;
    }


    export namespace Unions {
        export const PurchasedEventDetailItem = z.union([PurchasedEventDetailItemSpecified, PurchasedEventDetailItemProduct]);
        export const ChangeConstant = z.union([ChangeConstantGlobal, ChangeConstantUser]);
    }

}
"
`;

exports[`generateZod > generates generic/api.yml > generic/api 1`] = `
"import { z } from 'zod'
import * as zc from './zod-common.js'

export namespace Schemas {
    export const PetBase = z.object({ id: z.number().int().min(1), type: z.string() });
    export const GenericPet = PetBase.merge(z.object({ name: z.string().optional(), type: z.enum(['BIRD', 'HAMSTER']) }));
    export const Dog = PetBase.merge(z.object({ bark: z.string(), type: z.literal('DOG') }));
    export const ShortHair = PetBase.merge(z.object({ catType: z.literal('SHORT').default('SHORT'), angryLevel: z.string().optional(), color: z.string(), type: z.literal('CAT') }));
    export const Seam = PetBase.merge(z.object({ catType: z.literal('SEAM').default('SEAM'), angryLevel: z.string().regex(/\\w+/).optional(), color: z.string(), type: z.literal('CAT') }));
    export const Cat = zc.ZodUnionMatch.matcher("catType", { 'SEAM': Seam, 'SHORT': ShortHair, onDefault: z.object({ catType: z.string().transform((s) => \`unknown:\${s}\` as const) }).passthrough() });
    export const Pet = zc.ZodUnionMatch.matcher("type", { 'DOG': Dog, 'CAT': Cat, 'BIRD': GenericPet, 'HAMSTER': GenericPet, onDefault: z.object({ type: z.string().transform((s) => \`unknown:\${s}\` as const) }).passthrough() });
    export const Pets = z.array(Pet).max(100);
    export const CatBase = PetBase.merge(z.object({ color: z.string(), catType: z.enum(['SEAM', 'SHORT']).or(z.string().transform((s) => \`unknown:\${s}\` as const)).optional() }));

    export namespace Types {
        export type PetBase = z.infer<typeof Schemas.PetBase>;
        export type GenericPet = z.infer<typeof Schemas.GenericPet>;
        export type Dog = z.infer<typeof Schemas.Dog>;
        export type ShortHair = z.infer<typeof Schemas.ShortHair>;
        export type Seam = z.infer<typeof Schemas.Seam>;
        export type Cat = z.infer<typeof Schemas.Cat>;
        export type Pet = z.infer<typeof Schemas.Pet>;
        export type Pets = z.infer<typeof Schemas.Pets>;
        export type CatBase = z.infer<typeof Schemas.CatBase>;
    }


    export namespace Unions {
        export const Cat = z.union([Seam, ShortHair]);
        export const Pet = z.union([Cat, Dog, GenericPet]);
    }

}
"
`;

exports[`generateZod > generates pets-modular/pets-api.yml > pets-modular/pets-api 1`] = `
"import { z } from 'zod'
import * as zc from './zod-common.js'

export namespace Schemas {
    export const PetBase = z.object({ type: z.string(), name: z.string().optional() });
    export const DogEnum = z.enum(['DOG_A', 'DOG_B']).or(z.string().transform((s) => \`unknown:\${s}\` as const));
    export const Dog = PetBase.merge(z.object({ fluffy: z.boolean().optional(), breed: DogEnum.optional(), type: z.literal('DOG') }));
    export const Cat = PetBase.merge(z.object({ breed: z.enum(['CAT_A', 'CAT_B']).or(z.string().transform((s) => \`unknown:\${s}\` as const)).optional(), type: z.literal('CAT') }));
    export const Pet = zc.ZodUnionMatch.matcher("type", { 'DOG': Dog, 'CAT': Cat, onDefault: z.object({ type: z.string().transform((s) => \`unknown:\${s}\` as const) }).passthrough() });

    export namespace Types {
        export type PetBase = z.infer<typeof Schemas.PetBase>;
        export type DogEnum = z.infer<typeof Schemas.DogEnum>;
        export type Dog = z.infer<typeof Schemas.Dog>;
        export type Cat = z.infer<typeof Schemas.Cat>;
        export type Pet = z.infer<typeof Schemas.Pet>;
    }


    export namespace Unions {
        export const Pet = z.union([Cat, Dog]);
    }

}
"
`;

exports[`generateZod > generates pets-modular-complex/petstore-api.yml > pets-modular-complex/petstore-api 1`] = `
"import { z } from 'zod'
import * as zc from './zod-common.js'

export namespace Schemas {
    export const FluffLevel = z.enum(['A', 'B', 'C']).or(z.string().transform((s) => \`unknown:\${s}\` as const));
    export const SchemasToy = z.object({ id: z.string(), price: z.string(), kind: z.string(), someEnum: z.enum(['FOO', 'BAR']).or(z.string().transform((s) => \`unknown:\${s}\` as const)).optional(), fluffLevel: FluffLevel.optional(), targetGroup: z.string().optional().default('CHILDREN') });
    export const FluffyTeddy = z.object({ fluffLevel: FluffLevel.optional(), id: z.string(), price: z.string(), kind: z.literal('TEDDY'), targetGroup: z.string().optional().default('CHILDREN') });
    export const Ball = z.object({ id: z.string(), price: z.string(), kind: z.literal('BALL'), fluffLevel: FluffLevel.optional(), targetGroup: z.string().optional().default('CHILDREN') });
    export const PetToy = zc.ZodUnionMatch.matcher("kind", { 'BALL': Ball, 'TEDDY': FluffyTeddy, onDefault: z.object({ kind: z.string().transform((s) => \`unknown:\${s}\` as const) }).passthrough() });
    export const TargetGroup = z.string();
    export const SchemaUntitled = z.object({ untitledProp: z.string().optional() });
    export const Color = z.object({ colorId: z.string().optional(), untitled: SchemaUntitled.optional(), untitledProp: z.string().optional() });
    export const ComponentsSchemasToy = z.object({ name: z.string().optional(), color: Color.optional(), targetGroup: TargetGroup.optional().default('CHILDREN'), relates: PetToy.optional(), subId: z.string().optional(), id: z.string(), price: z.string(), kind: z.string(), someEnum: z.enum(['FOO', 'BAR']).or(z.string().transform((s) => \`unknown:\${s}\` as const)).optional(), fluffLevel: FluffLevel.optional() });
    export const Pet = z.object({ id: z.number().int(), toy: ComponentsSchemasToy.optional(), leastFavToy: SchemasToy.optional(), favFluffLevel: FluffLevel.optional(), tag: z.string().optional(), name: z.string() });
    export const Pets = z.array(Pet).max(100);
    export const SchemaTitled = z.object({ titledProp: z.string().optional() });
    export const HttpErrorCode = z.number().int();
    export const Error = z.object({ code: HttpErrorCode, message: z.string(), titledSchema: SchemaTitled.optional() });

    export namespace Types {
        export type FluffLevel = z.infer<typeof Schemas.FluffLevel>;
        export type SchemasToy = z.infer<typeof Schemas.SchemasToy>;
        export type FluffyTeddy = z.infer<typeof Schemas.FluffyTeddy>;
        export type Ball = z.infer<typeof Schemas.Ball>;
        export type PetToy = z.infer<typeof Schemas.PetToy>;
        export type TargetGroup = z.infer<typeof Schemas.TargetGroup>;
        export type SchemaUntitled = z.infer<typeof Schemas.SchemaUntitled>;
        export type Color = z.infer<typeof Schemas.Color>;
        export type ComponentsSchemasToy = z.infer<typeof Schemas.ComponentsSchemasToy>;
        export type Pet = z.infer<typeof Schemas.Pet>;
        export type Pets = z.infer<typeof Schemas.Pets>;
        export type SchemaTitled = z.infer<typeof Schemas.SchemaTitled>;
        export type HttpErrorCode = z.infer<typeof Schemas.HttpErrorCode>;
        export type Error = z.infer<typeof Schemas.Error>;
    }


    export namespace Unions {
        export const PetToy = z.union([Ball, FluffyTeddy]);
    }

}
"
`;

exports[`generateZod > generates pets-recursive/pets-api.yml > pets-recursive/pets-api 1`] = `
"import { z } from 'zod'
import * as zc from './zod-common.js'

export namespace Schemas {
    export const PetBase = z.object({ type: z.string() });
    export const Dog: z.ZodTypeAny = z.lazy(() => PetBase.merge(z.object({ friends: Pets.optional(), type: z.literal('DOG') })));
    export const Cat: z.ZodTypeAny = z.lazy(() => PetBase.merge(z.object({ enemies: Pets.optional(), type: z.literal('CAT') })));
    export const Pet = zc.ZodUnionMatch.matcher("type", { 'CAT': Cat, 'DOG': Dog, onDefault: z.object({ type: z.string().transform((s) => \`unknown:\${s}\` as const) }).passthrough() });
    export const Pets: z.ZodTypeAny = z.lazy(() => z.object({ pets: z.array(Pet).max(100).optional() }));

    export namespace Types {
        export type PetBase = z.infer<typeof Schemas.PetBase>;
        export type Dog = z.infer<typeof Schemas.Dog>;
        export type Cat = z.infer<typeof Schemas.Cat>;
        export type Pet = z.infer<typeof Schemas.Pet>;
        export type Pets = z.infer<typeof Schemas.Pets>;
    }


    export namespace Unions {
        export const Pet = z.union([Cat, Dog]);
    }

}
"
`;

exports[`generateZod > generates pets-simple/pets-api.yml > pets-simple/pets-api 1`] = `
"import { z } from 'zod'
import * as zc from './zod-common.js'

export namespace Schemas {
    export const PetBase = z.object({ id: z.number().int(), type: z.string() });
    export const Dog = PetBase.merge(z.object({ bark: z.string(), type: z.literal('DOG') }));
    export const Cat = PetBase.merge(z.object({ color: z.string(), type: z.literal('CAT') }));
    export const Pet = zc.ZodUnionMatch.matcher("type", { 'DOG': Dog, 'CAT': Cat, onDefault: z.object({ type: z.string().transform((s) => \`unknown:\${s}\` as const) }).passthrough() });
    export const Pets = z.array(Pet).max(100);

    export namespace Types {
        export type PetBase = z.infer<typeof Schemas.PetBase>;
        export type Dog = z.infer<typeof Schemas.Dog>;
        export type Cat = z.infer<typeof Schemas.Cat>;
        export type Pet = z.infer<typeof Schemas.Pet>;
        export type Pets = z.infer<typeof Schemas.Pets>;
    }


    export namespace Unions {
        export const Pet = z.union([Cat, Dog]);
    }

}
"
`;
